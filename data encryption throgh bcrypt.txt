
How to ecrpyt the data =>{
    we need to know these things before that 
    1. Encryption process
    2. Hashing  process
    3.salting 

    1. Encryption process =>{
        Encryption is a two-way function where data is passed in as plaintext and comes out as ciphertext, which is 
        unreadable. Since encryption is two-way, the data can be decrypted so it is readable again.

        ==> this is used to encript the data between client and server
            => this is two way function i.e => the data can be decrepted with a right decription key.
    }

    2.Hashing process =>{
        Hashing works by converting a readable text into an unreadable text of secure data. Hashing is efficiently 
        executed but extremely difficult to reverse. Like I stated earlier, hashing and encryption are often mistaken. 
        Encryption is a two-way function. The plaintext can be encrypted into ciphertext and decrypted back into plaintext
        using a unique key. The difference between encryption and hashing is that encryption is reversible while hashing 
        is irreversible.

        we can't be read the hashed data once it hashed.
        ==> this is used in login processes.
        because the password is hashed (unique string generated by this algorithm) and is validated by comparing the hashed 
        data in database.
    }

    3.salting =>[
        Salting is the process of adding unique random strings of characters to passwords in a database or each password 
        before the password is hashed (a term we'll come back to). This is done to change the hash and make passwords 
        more secure. The string of characters added to the password is called the salt. A salt can be added in front or 
        behind a password

        ==> salting is like adding more security to your passwords.
    ]

}

=> Here we using bcrupt =>{
     
    it is One way hashing - BCrypt is a one-way hash function to obfuscate the password such that it is not stored in 
    plain text. Salted hashing - Generating random bytes (the salt) and combining it with the password before hashing 
    creates unique hashes across each user's password.

    For example, with input password abc123xyz, cost 12, and a random salt, the output of bcrypt is the string

        $2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW
        \__/\/ \____________________/\_____________________________/
        Alg Cost      Salt                        Hash

    Where:

        $2a$: The hash algorithm identifier (bcrypt)
        12: Input cost (212 i.e. 4096 rounds)
        R9h/cIPz0gi.URNNX3kh2O: A radix-64 encoding of the input salt
        PST9/PgBkqquzi.Ss7KIUgO2t0jWMUW: A radix-64 encoding of the first 23 bytes of the computed 24 byte hash

    methods we are using while sign up =>{

        Before that u need to install bcrypt into our projetct
            npm install --save bcrypt
        
        1.bcrypt.genSalt(rounds, cb(err,salted value))

            rounds - [OPTIONAL] - the cost of processing the data. (default - 10)

            cb - [REQUIRED] - a callback to be fired once the salt has been generated. uses eio making it asynchronous. 
            err - First parameter to the callback detailing any errors. salt - Second parameter to the callback providing 
            the generated salt.

        2. bcrypt.hash('string',salt_value, cd(err,hashed value))
               
            string :- value we want to hash
            salt_value :- generated salt value (string) to add more secure tourity layer
            cd  :- function that handles err and final hashed value .

        3. bcrypt.compare(password,password_stored_in_database,cd)      =>{

            password                     <= user send his password as in request
            password_stored_in_database  <= password_stored_in_database
            cd   <= function which handels the error and success on comparison of password
        }

        when sign in , give a token to the user 
            
            -> install jsonwebtoke
            ->import that module where you want into a variable (jwt)
            
            -> jwt.sign(payload,secrete_key,{expiresIn:'1800s'})

                    payload-> object that contains user's detalis like(id,student:false,premium:true,...)
                    secrete_key -> key we stored in .env file we can access it via {  process.env.VARIABLE_NAME_IN_.ENV FILE}

                                    we can create this key with node by this command in our terminal

                                        require('crypto').randomBytes(64).toString('hex')            

                    {expiresIn} -> optional, time period states how long this token will be valid


            -> verifying the token 
                    jwt.verify( token_send_by_user, secrete_key stored in .env file , (err, user_payload))

                        cb -> handles error while verifyingtoken and 
                              returns palyload in the token {object}


    }

}